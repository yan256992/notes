## 🐾  Java并发机制的底层实现原理

> Java代码在编译后会变成java字节码文，字节码被类加载器加载到JVM中，JVM执行字节码，最终需要转换为汇编指令在CPU上执行。java中所使用的的并发机制依赖于JVM的实现和CPU指令

### Volatile的应用

> volatile是轻量级的synchcronized。在多处理器开发中保证了共享变量的“可见性”。可见性是指当一个线程修改一个共享变量的时候，另一个线程能读到这个修改的值。它不会引起线程的上下文切换和调度。

把某个变量声明为`volatile`的时候，在转换为汇编指令的时候会在后面加上一条lock指令，`lock`前缀的指令在多核处理器下会引发两件事

1. 将当前处理器缓存行的数据写回到系统内存
2. 这个写回操作会使其他CPU里缓存了该内存地址的数据无效

在多处理器下，为了保证每个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当发现自己的缓存行对应的内存地址已经被修改就将当前处理器的缓存行设置为无效状态，当下次需要该数据的时候就会直接从内存中读取数据

### synchronized的实现原理与应用

> java中每一个对象都可以作为锁。
>
> 对于普通方法，锁是当前的实例对象
>
> 对于静态同步方法，锁是当前类的Class对象
>
> 对于同步方法块，锁是Synchronized括号里配置的对象



### 原子操作的实现原理

