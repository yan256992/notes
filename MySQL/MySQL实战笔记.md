### Mysql的执行过程

<img src="https://gitee.com/yan256992/cloudimages/raw/master/img/image-20210730213500236.png" alt="image-20210730213500236" style="zoom:50%;" />

​                                                                Mysql的逻辑架构如图所示

1. #### 🔨连接器

   连接器主要负责与客户端进行连接，获取权限，维持和管理连接

   查看连接：如果command是sleep代表的就是空闲连接

   ![image-20210730213850613](https://gitee.com/yan256992/cloudimages/raw/master/img/image-20210730213850613.png)

   数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。

   

   如果全部使用长连接会导致内存涨的特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。

   **解决方案：**

   - 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。
   - 如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。

2. #### ==查询缓存==

查询缓存也就是说查询的时候首先看缓存中有没有数据（缓存中的数据采用的格式是 K-V键值对，其中K代表的是“sql语句”，V代表的是查询的结果）

 查询缓存的效率很低，这是因为如果有对表的更新，就会将整个缓存全部清空。在MySQL8.0  直接     将缓存功能删除掉了

3. #### ==分析器==

如果没有命中缓存就要执行sql语句了，首先要做的就是对sql语句进行解析，分析器会将语句进行   语法分析

~~~mysql
select SQL_CACHE * from T where ID=10；
~~~

MySQL 从你输入的"select"这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”

4. #### ==优化器==

优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的 join：

~~~mysql
select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;
~~~

- 既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。
- 也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。

5. #### ==执行器==

   执行的流程如下（假设ID没有索引）：

   - 调用InnoDB引擎接口取这个表的第一行，判断ID是否是10，如果不是就跳过，是就将结果存储在结果集中。
   - 调用引擎接口取下一行，重复判断逻辑，直到取到最后一行
   - 将结果集返回给客户端

   

### 日志系统

更新语句的执行过程和查询流程类似，但是更新语句还涉及到了两个重要的日志模块。即redo log（重做日志）和 binlog（归档日志）

#### 重要的日志模块： redo log

具体来说，当有一条记录需要更新的时候，==InnoDB 引擎==就会先把记录写到 redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。

redo log的大小固定

<img src="https://gitee.com/yan256992/cloudimages/raw/master/img/image-20210730220203607.png" alt="image-20210730220203607" style="zoom:50%;" />

write_pos记录当前记录的位置，一边写一边后移，写到第三个后面就回到0号文件开头。checkpoint记录的是当前要擦除的位置，也是往后移动并且循环的。==擦除之前要讲记录更新到磁盘文件==write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。

有了 redo log，==InnoDB== 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 **crash-safe**。

#### 重要的日志模块：binlog

redo log是InnoDB引擎独有的日志，在server也有自己的日志 就是binlog（归档日志）

<u>**两者的区别**：</u>

1. redo log 是 ==InnoDB 引擎特有==的；binlog 是 MySQL 的 ==Server 层==实现的，==所有引擎都可以使用==。
2. redo log 是==物理日志，==记录的是“在某个数据页上做了什么修改”；binlog 是==逻辑日志==，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。
3. redo log 是==循环==写的，空间固定会用完；binlog 是可以==追加==写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。



**update 语句时的内部流程：**

1. 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。

2. 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。

3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。

4. 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。

5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。

   浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。

<img src="https://gitee.com/yan256992/cloudimages/raw/master/img/image-20210730221512839.png" alt="image-20210730221512839" style="zoom:67%;" />

上图可以看出 redo log的写入拆分成了prepare 和 commit，这就是"两阶段提交"

原因：为了让两份日志之间的逻辑一致

redo log 用于保证 crash-safe 能力。innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数我建议你设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。

> redo log记录的是当时的数据是怎么变化的，比如备份的时候记录table表中字段a的值是1→3（由1变成3），而binlog里面记录可能就是多条SQL执行之后a的值才等于3，比如update table set a =1 where ID=1；update table set a=3 where ID=1；或者执行过更多SQL才变成3。

### 事务隔离

事务：事务是指逻辑上的一组操作，要么全部成功，要么全部失败

事务的四大特性是指ACID 即 

==原子性==：原子性是指要么成功 要么失败

 ==一致性==：修改前后数据的总量不会改变 例如转账前后 金额的总数不变

==持久性==：修改之后会写入到磁盘中 持久存储

==隔离性== ：事务之间不会相互影响

当数据库中有多个事务的时候 可能会出现 脏读 幻读 不可重复读

为了解决以上的问题就有了隔离级别的概念   事务的隔离级别越高 效率就会越低

**SQL标准的事务隔离级别包括：**

==读未提交==：一个事务还未提交，其他事务就可以看见他做的改变

==读提交==：只有当前事务提交之后 其他事务才能看见他的改变

==可重复读==：一个事务在执行过程中看到的数据，总是跟这个事务在启动的时候看到的数据是一致的，在当前的隔离级别下，未提交的事务对其他事物是不可见的

==串行化==：对于同一行数据，写会加写锁 读会加读锁 当读写发生冲突的时候 后访问的数据必须等待前面的事务完成才可以继续

在实现上面，数据库会创建一个视图，访问的时候以视图的逻辑结果为主，在“**可重复读**”的隔离级别下，这个视图是在==事务启动时创建==的，整个事务的存在期间都使用这个视图。“**读提交**”是在==SQL执行==的时候就开始创建。“读未提交”是直接在记录中获取值 不存在视图的概念

#### 事务隔离的实现

##### 可重复读的实现：

> 在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。

<img src="https://gitee.com/yan256992/cloudimages/raw/master/img/image-20210807222158020.png" alt="image-20210807222158020" style="zoom:50%;" />

当前的值是4 但是在查询这条数据的时候 不同时刻启动的事务会有不同的read-view。在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）

### 数据库的索引

> 索引的出现就是为了提高数据的查询效率，索引相当于书籍的目录

#### InnoDB的索引模型

每一个索引在InnoDB中对应一棵B+树，假设，我们有一个主键列为ID的表，表中有字段k，并且在k上有索引

<img src="https://gitee.com/yan256992/cloudimages/raw/master/img/image-20210807223305450.png" alt="image-20210807223305450" style="zoom:67%;" />

可以看出 根据叶子节点不同 可以将索引分为==主键索引==和==非主键索引==

主键索引的叶子节点是一行数据 在InnoDB中主键索引也被称为簇聚索引

非主键索引的叶子节点是主键的值 在InnoDB中 非主键索引也被称为二级索引

基于主键索引和普通索引的查询有什么区别？

~~~mysql
如果语句是select * from T where ID=500，即主键查询方式，则只需要搜索ID这棵B+树；
如果语句是select * from T where k=5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为回表。
~~~

#### 索引维护

在上述的数据表中从插入一个 ID值为700的数据 很容易 直接在后面插入就行了。但是如果插入的数据是400的话就不一样了，这时候需要将前面的数据挪动 空出位置。如果R5所在的页已经满了，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂 。

所以要有自增主键 这样就不会挪动数据 而是直接追加在后面。自增字段作为主键也可以减少存储空间的浪费。

假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？
       由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约20个字节，而如果用整型做主键，则只要4个字节，如果是长整型（bigint）则是8字节。显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。



执行语句select * from T where k between 3 and 5的流程如下：

1. 首先在K索引树上找到k=3的记录，取得ID=300；
2. 再到ID索引树上找到300对应的R3
3. 在K索引树上找到k=5 对应的ID=500
4. 回到ID索引树找到500对应的R4
5. 在K索引树取下一个值K=6，不满足条件。循环结束

**回到主键索引树搜索的过程， 我们称为回表**  

#### 覆盖索引

如果执行语句select ID from T where k between 3 and 5.这时候只需要查询ID的值。而ID的值已经在K索引树上了。因此可以直接返回查询的结果，不需要回表。也就是说，在这个查询里面。索引K已经覆盖了我们的查询请求，我们称之为覆盖索引

**由于覆盖索引可以减少树的搜索次数，显著提高查询性能，所以使用覆盖索引是一个常用的性能·优化手段**

例如在一个市民信息表上面。如果需要通过身份证号查询这个人的名字。那么就可以将身份证号和名字建立一个联合索引

#### 最左前缀原则

<img src="https://gitee.com/yan256992/cloudimages/raw/master/img/image-20210818213011304.png" alt="image-20210818213011304" style="zoom:80%;" />

**B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录**

可以看到， 索引项是按照索引定义里面出现的字段顺序排序的。
        当你的逻辑需求是查到所有名字是“张三”的人时， 可以快速定位到ID4， 然后向后遍历得到所有需要的结果。
如果你要查的是所有名字第一个字是“张”的人， 你的SQL语句的条件是"where name like‘张%’"。 这时， 你也能够用上这个索引， 查找到第一个符合条件的记录是ID3， 然后向后遍历，直到不满足条件为止。

可以看到， 不只是索引的全部定义， 只要满足最左前缀， 就可以利用索引来加速检索。 这个最左前缀可以是联合索引的最左N个字段， 也可以是字符串索引的最左M个字符。  

#### 索引下推

索引下推的意思是在索引遍历的过程中。对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数

### 全局锁和表锁

根据枷锁的范围吗，MYSQL里面的锁大致可以分为全局锁，表级锁，和行锁三类，

#### 全局锁

全局锁就是对整个数据库实例加锁。此时整个数据库处于只读状态

经典的使用场景是做全库的逻辑备份

#### 表级锁

MySQL中表级别的锁有两种，一种是表锁，一种是元数据锁

表锁的语法是 lock tables  .. . read/wrirte

如果在某个线程A中执行lock tables t1 read, t2 write; 这个语句， 则其他线程写t1、 读写t2的语句都会被阻塞。 同时， 线程A在执行unlock tables之前， 也只能  执行读t1、 读写t2的操作。 连写t1都不允许， 自然也不能访问其他表。  

另一类表级的锁是MDL，MDL不需要显示使用，在访问一个表的时候会被自动加上。他的作用是保证读写的正确性。

- 读锁之间不互斥， 因此你可以有多个线程同时对一张表增删改查。
- 读写锁之间、 写锁之间是互斥的， 用来保证变更表结构操作的安全性。 因此， 如果有两个线程要同时给一个表加字段， 其中一个要等另一个执行完才能开始执行  

<img src="https://gitee.com/yan256992/cloudimages/raw/master/img/image-20210818220224262.png" alt="image-20210818220224262" style="zoom:80%;" />

A执行的时候会加上读锁，B执行的时候同样，因为都是读 所以不会冲突，但是当执行C的时候就会被阻塞。后面D的也就被阻塞了。对所有的表的增删改查都需要==先申请读锁==

MDL会直到事务提交的时候才会释放